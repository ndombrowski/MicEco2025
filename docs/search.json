[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Microbial Ecology: Introduction into Data Analysis",
    "section": "",
    "text": "Nina Dombrowski\n\n\nInstitute for Biodiversity and Ecosystem Dynamics (IBED), University of Amsterdam (UVA)\n\n\nn.dombrowski@uva.nl\n\n\n\nIntroduction\nWelcome to the Microbial Ecology Command-Line Crash Course!\nIn this short tutorial, you will learn how to use the command line and a High-Performance Computing (HPC) environment in order to move from raw 16S sequencing reads to a basic count table of microbial taxa.\nThis course is designed for students in microbial ecology with little or no prior experience using the command line. During this tutorial, you will learn how to:\n\nInstall a Terminal\n\nHow to access a Unix/Linux command line\nHow to run basic commands\n\nDocument your Code\n\nHow to use markdown, Quarto, and comments in scripts\nHow to track your work and make your analyses reproducible\n\nNavigate the Command Line\n\nNavigating the filesystem (cd, ls, pwd)\nWorking with files (mkdir, cp, mv, rm, cat, head, less)\nSearching and filtering data (grep, wc, cut)\nViewing and understanding FASTQ files\n\nWork with an HPC\n\nConnecting to the cluster (SSH)\nUnderstanding file systems and job schedulers (e.g., SLURM)\nRunning and interpreting command-line tools (e.g., fastqc, seqkit)\nSetting up and activating conda environments\nRunning workflows with Snakemake",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "source/terminal.html",
    "href": "source/terminal.html",
    "title": "1  Setting up a terminal",
    "section": "",
    "text": "1.1 Terminology\nThe command-line interface (CLI) is an alternative to a graphical user interface (GUI), with which you are likely more familiar. Both allow you to interact with your computer’s operating system but in a slightly different way:\nThe CLI is also commonly called the shell, terminal, console, or prompt. These terms are related but not identical:\nThere are several types of shells — for example, bash or zsh (that use slightly different languages to issue commands). This tutorial was written on a computer that uses bash, which stands for Bourne Again Shell.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Setting up a terminal</span>"
    ]
  },
  {
    "objectID": "source/terminal.html#terminology",
    "href": "source/terminal.html#terminology",
    "title": "1  Setting up a terminal",
    "section": "",
    "text": "In a GUI, you click buttons, open folders, and use menus\nIn the CLI, you type text commands and see text output\n\n\n\nThe terminal (or console) is the window or program that lets you type commands. It is the interface you open, for example, Terminal on macOS, WSL on Windows, or an HPC login session.\nThe shell is the program that actually interprets the commands you type inside the terminal and tells the operating system what to do. The shell understands commands like cd that is used to change directories.\nPrompt: the text displayed by the shell that indicates it is ready to accept a command. The prompt often shows useful information, like your username, machine name, and current directory. Example of a prompt: user@machine:~$",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Setting up a terminal</span>"
    ]
  },
  {
    "objectID": "source/terminal.html#installation-guides",
    "href": "source/terminal.html#installation-guides",
    "title": "1  Setting up a terminal",
    "section": "1.2 Installation guides",
    "text": "1.2 Installation guides\n\n1.2.1 Linux\nIf you’re using Linux, you already have everything you need — no installation required. All Linux systems come with a terminal and a shell, and the default shell is usually Bash.\nYou can open a terminal from your applications menu or by searching for Gnome Terminal, KDE Konsole, or xterm, depending on your desktop environment.\nTo confirm which shell you’re using, type:\necho $SHELL\nIf the output does not end in /bash, you can start Bash manually by typing:\nbash\nYou should then see a new prompt (often ending in $) indicating that Bash is running.\n\n\n1.2.2 Mac\nAll Mac computers also come with a built-in terminal and shell. To open the terminal:\n\nIn Finder, go to Go → Utilities, then open Terminal.\nOr use Spotlight Search (⌘ + Space), type Terminal, and press Return.\n\nThe default shell depends on your macOS version:\n\nmacOS Mojave (10.14) or earlier → Bash\nmacOS Catalina (10.15) or later → Zsh\n\nCheck which shell you’re currently using:\necho $SHELL\nIf the output does not end in /bash, you can start Bash manually by typing:\nbash\nThen check again with echo $SHELL. If you have trouble switching, don’t worry — nearly all commands in this tutorial will also work in Zsh.\n\n\n1.2.3 Windows\nUnlike macOS or Linux, Windows doesn’t include a Unix-style terminal by default, so you’ll need to install one of the following:\n\nMobaXterm (recommended)\n\nProvides a terminal with Linux-like commands, built-in\nInstallation guide: MobaXterm setup instructions\nEasiest option for beginners and lightweight to install.\n\nWindows Subsystem for Linux (WSL2)\n\nGives you a full Linux environment directly on Windows.\nRecommended if you’re comfortable installing software or already have some command-line experience.\nUses Ubuntu by default, which includes Bash and all standard Linux tools.\nInstallation guide:Microsoft WSL install instructions\n\n\nOnce installed, open your terminal (MobaXterm or Ubuntu via WSL2) and verify that Bash is available:\necho $SHELL",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Setting up a terminal</span>"
    ]
  },
  {
    "objectID": "source/terminal.html#sanity-check",
    "href": "source/terminal.html#sanity-check",
    "title": "1  Setting up a terminal",
    "section": "1.3 Sanity check",
    "text": "1.3 Sanity check\nAfter setup, open your terminal. You should see something like this:\n\nIf you see a prompt ending in $ (for example user@machine:~$), your shell is ready — you’re all set to follow along with the tutorial!",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Setting up a terminal</span>"
    ]
  },
  {
    "objectID": "source/documentation.html",
    "href": "source/documentation.html",
    "title": "2  Documenting your code",
    "section": "",
    "text": "2.1 Choosing your editor\nDocumenting your code is crucial for both your future self and anyone else who might work with your code. Good documentation helps others (and your future self) understand the purpose, functionality, and usage of your scripts, much like a detailed lab notebook.\nFor more in-depth guidance, see A Guide to Reproducible Code in Ecology and Evolution. While examples are mainly in R, the principles are general and apply across programming languages.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Documenting your code</span>"
    ]
  },
  {
    "objectID": "source/documentation.html#choosing-your-editor",
    "href": "source/documentation.html#choosing-your-editor",
    "title": "2  Documenting your code",
    "section": "",
    "text": "2.1.1 Plain text editor\nAvoid visual editors like Word, as they are not designed for code and can inadvertently change syntax (e.g., replacing backticks \\`` with apostrophes’`).\nStart simple with a plain text editor, such as:\n\nTextEdit (Mac)\nNotepad (Windows)\n\nThese allow you to write and save code safely, though they lack advanced features like syntax highlighting or integrated code execution.\n\n\n2.1.2 Rmarkdown in RStudio\nRMarkdown combines plain text, code, and documentation in one document. You can write your analysis and explanatory text together, then “knit” the document to HTML, PDF, or Word.\nTo create an RMarkdown file in RStudio:\n\nGo to File → New File → R Markdown\nChoose a title, author, and output format\nWrite your code and text\nClick Knit to render the document\n\nMore info: RMarkdown tutorial\n\n\n2.1.3 Quarto in Rstudio\nQuarto is a next-generation alternative to RMarkdown. It supports R, Python, and other languages, and offers more output formats and customization options.\nTo create a Quarto document:\n\nGo to File → New File → Quarto Document\nChoose a title, author, and output format\nClick Render to generate your document\n\nMore info: Quarto documentation",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Documenting your code</span>"
    ]
  },
  {
    "objectID": "source/documentation.html#markdown-for-documentation",
    "href": "source/documentation.html#markdown-for-documentation",
    "title": "2  Documenting your code",
    "section": "2.2 Markdown for Documentation",
    "text": "2.2 Markdown for Documentation\nMarkdown is a lightweight language for formatting text. You can easily add headers, lists, links, code, images, and tables.\nHeaders:\nUse # to add a header and separate different sections of your documentation. The more # symbols you use after each other, the smaller the header will be. When writing a header make sure to always put a space between the # and the header name.\n# Main Header\n## Subheader\nLists:\nUse - or * for unordered lists and numbers for ordered lists.\nOrdered lists are created by using numbers followed by periods. The numbers do not have to be in numerical order, but the list should start with the number one.\n1. First item\n2. Second item\n3. Third item\n4. Fourth item \n1. First item\n2. Second item\n3. Third item\n    1. Indented item\n    2. Indented item\n4. Fourth item \nUnordered lists are created using dashes (-), asterisks (*), or plus signs (+) in front of line items. Indent one or more items to create a nested list.\n- First item\n- Second item\n- Third item\n- Fourth item \n - First item\n- Second item\n- Third item\n    - Indented item\n    - Indented item\n- Fourth item \nYou can also combine ordered with unordered lists:\n1. First item\n2. Second item\n3. Third item\n    - Indented item\n    - Indented item\n4. Fourth item\nCode Blocks:\nEnclose code snippets in triple backticks followed by the computational language, i.e. bash or python, used.\n```bash\ngrep \"control\" downloads/Experiment1.txt\n```\nLinks:\nYou can easily add links to external resources or within your documentation as follows:\n[Link Text](https://www.example.com)\nEmphasis:\nYou can use * or _ to write italic and ** or __ for bold text.\n*italic*\n**bold**\nPictures\nYou can also add images to your documentation as follows:\n![Alt Text](path/to/your/image.jpg)\nHere, replace Alt Text with a descriptive alternative text for your image, and path/to/your/image.jpg with the actual path or URL of your image.\nTables\nTables can be useful for organizing information. Here’s a simple table:\n| Header 1 | Header 2 |\n| ---------| ---------|\n| Content 1| Content 2|\n| Content 3| Content 4|",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Documenting your code</span>"
    ]
  },
  {
    "objectID": "source/cli.html",
    "href": "source/cli.html",
    "title": "3  Navigating the command line",
    "section": "",
    "text": "3.1 pwd: Find out where we are\nOnce your terminal is open, let’s get oriented by typing your first command:\npwd\nThe command pwd stands for print working directory. It tells you where you currently are in the file system — that is, which folder (directory) your shell is “looking at” right now. You should see something like:",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Navigating the command line</span>"
    ]
  },
  {
    "objectID": "source/cli.html#pwd-find-out-where-we-are",
    "href": "source/cli.html#pwd-find-out-where-we-are",
    "title": "3  Navigating the command line",
    "section": "",
    "text": "/Users/YourUserName\n\n\n\n\n\n\nTipTip: Finding the Desktop on Different Systems\n\n\n\n\n\nYour home directory path varies slightly across operating systems. Here’s how to locate yourself and connect to familiar locations like the Desktop:\nmacOS\n\nYour home directory is /Users/YourUserName\nTo open the folder you are currently in Finder:open .\nYour desktop is at /Users/YourUserName/Desktop\n\nMobaXterm (Windows)\n\nYour home directory is /home/mobaxterm\nBy default, this is temporary and is deleted when you close MobaXterm. To make it permanent:\n\nGo to Settings –&gt; Configuration –&gt; General\nUnder Persistent home directory, choose a folder of your choice\n\nTo open the folder you are currently in the Windows File explorer: explorer.exe .\nYour Desktop is usually at: /mnt/c/Users/YourUserName/Desktop or /mnt/c/Users/YourUserName/OneDrive/Desktop (when using OneDrive)\n\nWSL2 (Windows)\n\nYour home directory is/home/YourUserName\nTo open the folder you are currently in the Windows File explorer: explorer.exe .\nYour Desktop is usually at: /mnt/c/Users/YourUserName/Desktop or /mnt/c/Users/YourUserName/OneDrive/Desktop (when using OneDrive)\n\nIf you want to access the Uva OneDrive folder:\nIf your OneDrive folder name includes spaces (like OneDrive - UvA), use quotes around the path:\n\ncd \"/mnt/c/Users/YourUserName/OneDrive - UvA\"",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Navigating the command line</span>"
    ]
  },
  {
    "objectID": "source/cli.html#ls-list-the-contents-of-a-directory",
    "href": "source/cli.html#ls-list-the-contents-of-a-directory",
    "title": "3  Navigating the command line",
    "section": "3.2 ls: List the contents of a directory",
    "text": "3.2 ls: List the contents of a directory\nNow that we know where we are, let’s find out what is inside that location. The command ls (short for list) shows the files and folders in your current directory. Type the following and press enter:\n\nls\n\nYou should see something like this (your output will vary depending on what’s in your directory):\n\nThe colors and formatting depend on your terminal settings, but typically:\n\nFolders (directories) appear in one color (often green or blue)\nFiles appear in another (often white or bold)\n\nIf your directory contains many items, the output can quickly become overwhelming. To make sense of it, we can use options and arguments to control how commands behave.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Navigating the command line</span>"
    ]
  },
  {
    "objectID": "source/cli.html#the-structure-of-a-command",
    "href": "source/cli.html#the-structure-of-a-command",
    "title": "3  Navigating the command line",
    "section": "3.3 The structure of a command",
    "text": "3.3 The structure of a command\nA command generally has three parts:\n\nA command: The program you want to run, i.e. ls\nAn option (or flag): A way to modify how the command behaves, i.e -l (long format)\nAn optional argument: The input, i.e. a file or folder\n\n\nTry the following command in your current directory to “List (ls) the contents of the current folder and show details in long format (-l)”:\n\nls -l\n\nAfter running this you should see a more detail list of the contents of your folder.In the example below we can see that we now print additional information about who owns the files (i.e. access modes), how large the files are, when they were last modified and of course the name:",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Navigating the command line</span>"
    ]
  },
  {
    "objectID": "source/cli.html#getting-help",
    "href": "source/cli.html#getting-help",
    "title": "3  Navigating the command line",
    "section": "3.4 Getting help",
    "text": "3.4 Getting help\nAt some point, you’ll want to know what options a command has or how it works. In this case, you can always check the manual pages (or man pages). Try this:\n\nman ls\n\nThis opens the manual entry for the command ls. You can scroll through it using:\n\n↑ / ↓ arrows or the space bar to move down,\nb to move back up,\nq to quit the manual.\n\nNot all commands use man. Depending on the program, there are a few common patterns you can try\n\nman ls\nls --help\nls -h\n\nFor complex software, like bioinformatics tools, the most helpful documentation is often:\n\nThe tool’s official website or GitHub repository\nThe –help output that lists all parameters and examples",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Navigating the command line</span>"
    ]
  },
  {
    "objectID": "source/cli.html#mkdir-make-a-new-folder",
    "href": "source/cli.html#mkdir-make-a-new-folder",
    "title": "3  Navigating the command line",
    "section": "3.5 mkdir: Make a new folder",
    "text": "3.5 mkdir: Make a new folder\nBefore we start moving around, let’s first learn how to create new folders (also called directories).This is something we will do often, for example, to keep raw data, results, and scripts organized in separate places. The command we use for that is mkdir, which stands for make directory.\nFor now, we will use mkdir to create a shared working folder for this tutorial. Don’t worry about how to move into the folder yet — we’ll cover that in a bit.\n\n# Move into the home directory (the starting point of your system)\ncd ~\n\n# Create a new folder called 'data_analysis'\nmkdir data_analysis\n\n# Check that the folder was created successfully\nls\n\nYou should see a new folder called data_analysis appear in the list. We will use this folder as our project space for all exercises in this tutorial. You can easily make a new data folder inside this folder by typing the following:\n\n# Make a data folder inside the data_analysis folder\nmkdir data_analysis/data\n\n# Confirm that this works\n# Notice here, how we use ls not with a flag but with an optional argument?\nls data_analysis\n\n\n\n\n\n\n\nTipTip: Commenting your code\n\n\n\n\n\nNotice how we added # and some notes above each command?\nAnything written after # in Bash is a comment — it won’t be executed, but it helps you (and others) understand what the command does.\nIn your own work, add short, meaningful comments above key steps. Avoid restating the obvious — instead, explain why you’re doing something or what it achieves.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Navigating the command line</span>"
    ]
  },
  {
    "objectID": "source/cli.html#cd-move-around-folders",
    "href": "source/cli.html#cd-move-around-folders",
    "title": "3  Navigating the command line",
    "section": "3.6 cd: Move around folders",
    "text": "3.6 cd: Move around folders\nNow that we have our own project folder, let’s learn how to move around the file system.\nThe file system is structured like a tree that starts from a single root directory (that is also denoted as / in bash). All other folders branch out from this root directory.\n\nThere are two ways to specify a path:\n\nAbsolute path: starts from the root (e.g. /Users/John/Documents)\nRelative path: starts from your current location (e.g. Documents if you’re already in /Users/John)\n\nLet’s practice moving between folders (at each step, use pwd in case you feel that you get lost):\n\n# Move into the data analysis folder \ncd data_analysis \n\n# Check where we are \npwd\n\nWe now should see that we are in something like /Users/Name/data_analysis. We can use the cd command in multiple ways:\n\n# Move into the data folder\ncd data\n\n# Move one level up, i.e. go back to the data_analysis folder\ncd ..\n\n# Move multiple levels at once\ncd data_analysis/data\n\n# Quickly go back home\ncd ~\n\n# And go back to the data_analysis folder \ncd data_analysis\n\nIn the code above, the tilde symbol (~) is a shortcut for your home directory. It’s equivalent to typing the full absolute path to your home (e.g. /Users/YourName) but it is much faster to type.\n\n\n\n\n\n\nTipTip: Command-line completion\n\n\n\n\n\nSome tips for faster navigation:\n\nUse Tab for autocompletion — type the first few letters of a folder name and press Tab.\nIf there’s more than one match, press Tab twice to see all options.\nUse ↑ / ↓ arrows to scroll through previously entered commands\n\n\n\n\n\n\n\n\n\n\nCautionExercise\n\n\n\n\n\n\nCreate a new folder inside your data_analysis directory called results\nMove into that folder and confirm your location with pwd\nMove back to data_analysis using cd\nUse ls to confirm both results and data are there",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Navigating the command line</span>"
    ]
  },
  {
    "objectID": "source/cli.html#wget-download-data",
    "href": "source/cli.html#wget-download-data",
    "title": "3  Navigating the command line",
    "section": "3.7 wget: Download data",
    "text": "3.7 wget: Download data\nNext, let’s download a genome fasta file to go through some other useful commands. We’ll use the wget command to fetch a file barcode01_merged.fastq.gz from the NCBI database:\n\n# Download the example fasta into the current directory\nwget https://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/000/005/845/GCF_000005845.2_ASM584v2/GCF_000005845.2_ASM584v2_genomic.fna.gz\n\nAfter you download data, it is always a good idea to do some sanity check to see if the file is present and check how large it is:\n\n# List files in long (-l) and human-readable (-h) format\n# combining these two commands becomes -lh\nls -lh GCF_000005845.2_ASM584v2_genomic.fna.gz",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Navigating the command line</span>"
    ]
  },
  {
    "objectID": "source/cli.html#cp-copy-files",
    "href": "source/cli.html#cp-copy-files",
    "title": "3  Navigating the command line",
    "section": "3.8 cp: Copy files",
    "text": "3.8 cp: Copy files\ncp duplicates files or directories. Let’s use it to copy the downloaded file into data:\n\n# Copy file into data \ncp GCF_000005845.2_ASM584v2_genomic.fna.gz data/\n\n# Show content of both locations\nls -l\nls -l data\n\nWhen running the two ls commands, we see that we now have two copies of GCF_000005845.2_ASM584v2_genomic.fna.gz, one file is in our working directory and the other one is in our data folder. Having large files in multiple locations is generally not ideal since we will use unneccassary space. However, we can use another command to move the tar folder into our data folder.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Navigating the command line</span>"
    ]
  },
  {
    "objectID": "source/cli.html#mv-move-or-rename-files",
    "href": "source/cli.html#mv-move-or-rename-files",
    "title": "3  Navigating the command line",
    "section": "3.9 mv: Move (or rename) files",
    "text": "3.9 mv: Move (or rename) files\nmv moves or renames files without creating a second copy:\n\n# Move the file into data\nmv GCF_000005845.2_ASM584v2_genomic.fna.gz data/\n\n# Verify\nls -l\nls -l data\n\nNotice that mv will move a file and, without asking, overwrite the existing genome file we had in the data folder when we ran cp. This means for you that if you run mv its best to make sure that you do not overwrite files by mistake.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Navigating the command line</span>"
    ]
  },
  {
    "objectID": "source/cli.html#rm-remove-files-and-directories",
    "href": "source/cli.html#rm-remove-files-and-directories",
    "title": "3  Navigating the command line",
    "section": "3.10 rm: Remove files and directories",
    "text": "3.10 rm: Remove files and directories\nTo remove files and folders, we use the rm command. We want to remove the GCF_000005845.2_ASM584v2_genomic.fna.gz file since we do not need two copies:\n\n# Remove a file\nrm data/GCF_000005845.2_ASM584v2_genomic.fna.gz\n\n# Check if that worked\nls -l data\n\nIf we want to remove a folder, we need to tell rm that we want to remove folders using an option. To do this, we use -r , which allows us to remove directories and their contents recursively.\n\n\n\n\n\n\nImportant\n\n\n\nUnix does not have an undelete command.\nThis means that if you delete something with rm, it’s gone. Therefore, use rm with care and check what you write twice before pressing enter! Also, NEVER run rm -rf on the root / folder or any important path. Always double check the path or file name before pressing enter.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Navigating the command line</span>"
    ]
  },
  {
    "objectID": "source/cli.html#exploring-file-contents",
    "href": "source/cli.html#exploring-file-contents",
    "title": "3  Navigating the command line",
    "section": "3.13 Exploring file contents",
    "text": "3.13 Exploring file contents\nThere are different ways, to explore the content of a file, below you find the most common options.\n\n3.13.1 cat: Print the full file\nWe can use cat print the entire file to the screen — fine for short files, but overwhelming for long ones, which for our file is the case as we will see the nucleotides just running across the screen.\n\ncat data/GCF_000005845.2_ASM584v2_genomic.fna\n\n\n\n3.13.2 head and tail: View parts of a file\nTo only print the first few or last few lines we can use the head and tail command, respectively:\n\n# Show the first 10 lines (default)\nhead data/GCF_000005845.2_ASM584v2_genomic.fna\n\n# Show the last 5 lines\n# Here, the option -n allows us to control how many lines get printed\ntail -n 5 data/GCF_000005845.2_ASM584v2_genomic.fna\n\n\n\n3.13.3 less: View the full file\nless let’s you view a file’s contents one screen at a time. This is useful when dealing with a large text file (such as a sequence data file) because it doesn’t load the entire file but accesses it page by page, resulting in fast loading speeds.\n\nless -S data/GCF_000005845.2_ASM584v2_genomic.fna\n\n\nYou can use the arrow Up and Page arrow keys to move through the text file\nTo exit less, type q\n\n\n\n\n\n\n\nTipTip: Editing text files\n\n\n\n\n\nYou can also edit the content of a text file and there are different programs available to do this on the command line, the most commonly used tool is nano, which should come with most command line interpreters. You can open any file as follows:\n\nnano data/GCF_000005845.2_ASM584v2_genomic.fna\n\nOnce the document is open you can edit it however you want and then\n\nClose the document with control + X\nType y to save changes and press enter",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Navigating the command line</span>"
    ]
  },
  {
    "objectID": "source/cli.html#wc-count-things",
    "href": "source/cli.html#wc-count-things",
    "title": "3  Navigating the command line",
    "section": "3.14 wc: Count things",
    "text": "3.14 wc: Count things\nAnother useful tool is the wc (= wordcount) command that allows us to count the number of lines via -l in a file. It is an useful tool for sanity checking and here allows us to count how many lines of text are found in the text document.\n\nwc -l data/GCF_000005845.2_ASM584v2_genomic.fna\n\nWe see that this file does contain 58,022 lines of text. For fasta files this is not very informative, but once you have a dataframe with rows and columns where you filter rows using certain conditions this can become very useful for sanity checking.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Navigating the command line</span>"
    ]
  },
  {
    "objectID": "source/cli.html#pipes",
    "href": "source/cli.html#pipes",
    "title": "3  Navigating the command line",
    "section": "3.16 Pipes",
    "text": "3.16 Pipes\nSo far, we’ve run one command at a time — for example, using wc -l to count lines or head to look at the first few lines. But often, you’ll want to combine commands so that the output of one becomes the input of another. That’s what the pipe (|) does.\n\n# Example: show only the first 10 lines and count how many lines of text that is\nhead -n 100 data/GCF_000005845.2_ASM584v2_genomic.fna | grep -c \"CATGAAACGCA\" \n\nHere:\n\nhead -n 100 data/GCF_000005845.2_ASM584v2_genomic.fna prints the first 100 lines\nThe pipe (|) sends these 100 lines directly to the grep command\ngrep -c \"CATGAAACGCA\" only counts how often the nucleotide motif occurs in the first 100 lines of the fasta file",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Navigating the command line</span>"
    ]
  },
  {
    "objectID": "source/cli.html#zcat-and-head-working-with-compressed-files",
    "href": "source/cli.html#zcat-and-head-working-with-compressed-files",
    "title": "3  Navigating the command line",
    "section": "3.14 zcat and head: Working with compressed files",
    "text": "3.14 zcat and head: Working with compressed files\nNow that you know how to combine commands, let’s try the same idea with a compressed file.\nThe .gzending we have in the sequence data file means that the file is compressed with gzip. To view its contents without uncompressing it, we use zcat. Because these files can be very large, we’ll use a pipe again to only view the first few line\n\nzcat raw_reads/barcode01_merged.fastq.gz | head\n\nThis command:\n\nDecompresses the file temporarily (zcat),\nSends the decompressed text through a pipe (|),\nDisplays only the first few lines (head).\n\nFor macOS users, the equivalent command is often gzcat:\n\ngzcat raw_reads/barcode01_merged.fastq.gz | head",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Navigating the command line</span>"
    ]
  },
  {
    "objectID": "source/cli.html#working-with-multiple-files",
    "href": "source/cli.html#working-with-multiple-files",
    "title": "3  Navigating the command line",
    "section": "3.17 Working with multiple files",
    "text": "3.17 Working with multiple files\nSo far, we’ve worked with single files. In practice, sequencing data often comes as multiple files — for example, one FASTQ file per barcode. Let’s practice handling several files at once. Let’s begin by getting more genomes!\n\n# Download more data \nwget https://ftp.ncbi.nlm.nih.gov/genomes/all/GCA/002/813/895/GCA_002813895.1_ASM281389v1/GCA_002813895.1_ASM281389v1_genomic.fna.gz -P data\nwget https://ftp.ncbi.nlm.nih.gov/genomes/all/GCA/002/813/895/GCA_002813895.1_ASM281389v1/GCA_002813895.1_ASM281389v1_protein.faa.gz -P data\n\nwget https://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/000/317/675/GCF_000317675.1_ASM31767v1/GCF_000317675.1_ASM31767v1_genomic.fna.gz -P data\nwget https://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/000/317/675/GCF_000317675.1_ASM31767v1/GCF_000317675.1_ASM31767v1_protein.faa.gz -P data\n\n# Check what was done\nls -lh data\n\nWe now should have 6 files, 5 of which are still compressed. Notice, how there are some slight differences:\n\nThe file names start with either GCA or GCF indicating that they come from the GenBank versus RefSeq database\nThe file names end with either fna.gz or faa.gz indicating that the contain nucleotide versus protein sequences\n\n\n\n\n\n\n\nTipHint: Downloading many files with a for loop\n\n\n\n\n\nOnce you understand how to use wget, you can easily scale it up to download multiple files automatically using a simple for loop.\nFor example, suppose you have a list of NCBI genome URLs stored in a file called urls.txt — one per line:\nhttps://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/000/005/845/GCF_000005845.2_ASM584v2/GCF_000005845.2_ASM584v2_genomic.fna.gz\nhttps://ftp.ncbi.nlm.nih.gov/genomes/all/GCA/002/813/895/GCA_002813895.1_ASM281389v1/GCA_002813895.1_ASM281389v1_protein.faa.gz \nYou can then loop through all URLs and download them into the data folder like this:\n\nfor url in $(cat urls.txt); do\n    wget \"$url\"\ndone\n\nHere’s what happens:\n\n$(cat urls.txt) reads all lines from the file\nfor url in ... goes through each line one by one\nwget data \"$url\" downloads each genome into the current folder\n\nA more detailed explanation about for-loops can be found here.\n\n\n\n\n3.17.1 Wildcards (*): Match multiple files\nImagine we want to uncompress all the new files. Typing every filename can get tedious. Wildcards help you work with groups of files using pattern matching.\n\n# List all files inside the data folder that end with gz\nls data/*gz\n\n# List all protein fasta files inside the data folder \n# using `*faa*` means we look for filenames that contain a faa inside the name and that we allow for characters before and after\nls data/*faa*\n\n# If we would not add a asterisk after the faa we do not get any files, because none of the files end with faa\nls data/*faa\n\nWe can use Wildcards with every bash command and use it to unzip every file at once with:\n\ngzip -d data/*gz\n\n# Check if that worked\nls -lh data\n\n\n\n3.17.2 cat: Combining files\nThe cat command doesn’t just print files — it can also concatenate (join) multiple files into one. For example, if you have several protein files and want to merge them:\n\n# Combine the protein fasta files into one\ncat data/*faa &gt; proteins.faa\n\nHere:\n\ndata/*faaselects all files in the data folder that end with faa\n&gt; tells the shell to write the combined output into a new file called proteins.faa\n\n\n\n\n\n\n\nCautionImportant: Be careful with &gt;\n\n\n\n\n\nThe &gt; operator overwrites files without asking. If you want to add (append) to an existing file instead of replacing it, use &gt;&gt;:\n\n\n\nWhenever you modify files it is a good idea to do some sanity checks. Luckily, we already learned about useful ways to do this:\n\n# Check how many protein files are in the individual faa files \ngrep -c \"&gt;\" data/*faa\n\n# Check how many protein files are in concatenated file\n# Hopefully the numbers add up\ngrep -c \"&gt;\" proteins.faa",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Navigating the command line</span>"
    ]
  },
  {
    "objectID": "source/cli.html#gzip-uncompressing-files",
    "href": "source/cli.html#gzip-uncompressing-files",
    "title": "3  Navigating the command line",
    "section": "3.11 gzip: (Un)compressing files",
    "text": "3.11 gzip: (Un)compressing files\nYou might have noticed that the file we downloaded ends with .gz. This extension is used for files that are compressed to make the file smaller. This is useful for saving files, but this makes the file unreadable for a human. To be able to learn how to read the content of a file, let’s uncompress the file first.\n\n# Download the genome again \n# Here, we use the -P option to directly download the file into the data folder \nwget https://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/000/005/845/GCF_000005845.2_ASM584v2/GCF_000005845.2_ASM584v2_genomic.fna.gz -P data\n\n# Check that this worked \nls data\n\n# Uncompress the file with gzip \n# Here, we use -d to decompress the file (by default gzip will compress a file)\ngzip -d data/GCF_000005845.2_ASM584v2_genomic.fna.gz \n\n# Check that this worked \nls data",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Navigating the command line</span>"
    ]
  },
  {
    "objectID": "source/cli.html#zcat-decompress-and-print-to-screen",
    "href": "source/cli.html#zcat-decompress-and-print-to-screen",
    "title": "3  Navigating the command line",
    "section": "3.12 zcat: Decompress and print to screen",
    "text": "3.12 zcat: Decompress and print to screen\ngzip will decompress the file and allows us to read the content of the fasta file. This is perfect for large files, but not ideal sequence data files since these files get rather larger and we might not want to decompress these files as they would clutter our system.\nLuckily, there is one useful tool in bash to decompress the file and print the content to the screen called zcat which will print the content of a file to the screen but leave the file as is.\n\n# Download another file to see how zcat works \nwget https://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/016/864/595/GCF_016864595.1_ASM1686459v1/GCF_016864595.1_ASM1686459v1_genomic.fna.gz -P data \n\n# Check the content of the data folder \n# We should have one compressed and one uncompressed file \nls data\n\n# Use zcat on the compressed file \nzcat data/GCF_016864595.1_ASM1686459v1_genomic.fna.gz\n\n# Check the content of the data folder \n# We still should have one compressed and one uncompressed file \nls data",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Navigating the command line</span>"
    ]
  },
  {
    "objectID": "source/cli.html#grep-print-lines-that-match-patterns",
    "href": "source/cli.html#grep-print-lines-that-match-patterns",
    "title": "3  Navigating the command line",
    "section": "3.15 grep : print lines that match patterns",
    "text": "3.15 grep : print lines that match patterns\nThe grep command searches for patterns in a file. We could for example use this to ask how often a specific nucleotide motif occurs in our fasta file.\n\ngrep \"CATGAAACGCA\" data/GCF_000005845.2_ASM584v2_genomic.fna\n\nWe see, highlighted in red, where we find the pattern in the nucleotide sequence. If we simply are interested in the number of files that match our pattern, we could add the option -c to count how often the pattern we search for occurs:\n\ngrep -c \"CATGAAACGCA\" data/GCF_000005845.2_ASM584v2_genomic.fna",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Navigating the command line</span>"
    ]
  }
]