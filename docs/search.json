[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Microbial Ecology: Introduction into Data Analysis",
    "section": "",
    "text": "Nina Dombrowski\n\n\nInstitute for Biodiversity and Ecosystem Dynamics (IBED), University of Amsterdam (UVA)\n\n\nn.dombrowski@uva.nl\n\n\n\nIntroduction\nWelcome to the Microbial Ecology Command-Line Crash Course!\nIn this short tutorial, you will learn how to use the command line and a High-Performance Computing (HPC) environment in order to move from raw 16S sequencing reads to a basic count table of microbial taxa.\nThis course is designed for students in microbial ecology with little or no prior experience using the command line. During this tutorial, you will learn how to:\n\nInstall a Terminal\n\nHow to access a Unix/Linux command line\nHow to run basic commands\n\nDocument your Code\n\nHow to use markdown, Quarto, and comments in scripts\nHow to track your work and make your analyses reproducible\n\nNavigate the Command Line\n\nNavigating the filesystem (cd, ls, pwd)\nWorking with files (mkdir, cp, mv, rm, cat, head, less)\nSearching and filtering data (grep, wc, cut)\nViewing and understanding FASTQ files\n\nWork with an HPC\n\nConnecting to the cluster (SSH)\nUnderstanding file systems and job schedulers (e.g., SLURM)\nRunning and interpreting command-line tools (e.g., fastqc, seqkit)\nSetting up and activating conda environments\nRunning workflows with Snakemake",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "source/terminal.html",
    "href": "source/terminal.html",
    "title": "1  Setting up a terminal",
    "section": "",
    "text": "1.1 Terminology\nThe command-line interface (CLI) is an alternative to a graphical user interface (GUI), with which you are likely more familiar. Both allow you to interact with your computer’s operating system but in a slightly different way:\nThe CLI is also commonly called the shell, terminal, console, or prompt. These terms are related but not identical:\nThere are several types of shells — for example, bash or zsh (that use slightly different languages to issue commands). This tutorial was written on a computer that uses bash, which stands for Bourne Again Shell.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Setting up a terminal</span>"
    ]
  },
  {
    "objectID": "source/terminal.html#terminology",
    "href": "source/terminal.html#terminology",
    "title": "1  Setting up a terminal",
    "section": "",
    "text": "In a GUI, you click buttons, open folders, and use menus\nIn the CLI, you type text commands and see text output\n\n\n\nThe terminal (or console) is the window or program that lets you type commands. It is the interface you open, for example, Terminal on macOS, WSL on Windows, or an HPC login session.\nThe shell is the program that actually interprets the commands you type inside the terminal and tells the operating system what to do. The shell understands commands like cd that is used to change directories.\nPrompt: the text displayed by the shell that indicates it is ready to accept a command. The prompt often shows useful information, like your username, machine name, and current directory. Example of a prompt: user@machine:~$",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Setting up a terminal</span>"
    ]
  },
  {
    "objectID": "source/terminal.html#installation-guides",
    "href": "source/terminal.html#installation-guides",
    "title": "1  Setting up a terminal",
    "section": "1.2 Installation guides",
    "text": "1.2 Installation guides\n\n1.2.1 Linux\nIf you’re using Linux, you already have everything you need — no installation required. All Linux systems come with a terminal and a shell, and the default shell is usually Bash.\nYou can open a terminal from your applications menu or by searching for Gnome Terminal, KDE Konsole, or xterm, depending on your desktop environment.\nTo confirm which shell you’re using, type:\necho $SHELL\nIf the output does not end in /bash, you can start Bash manually by typing:\nbash\nYou should then see a new prompt (often ending in $) indicating that Bash is running.\n\n\n1.2.2 Mac\nAll Mac computers also come with a built-in terminal and shell. To open the terminal:\n\nIn Finder, go to Go → Utilities, then open Terminal.\nOr use Spotlight Search (⌘ + Space), type Terminal, and press Return.\n\nThe default shell depends on your macOS version:\n\nmacOS Mojave (10.14) or earlier → Bash\nmacOS Catalina (10.15) or later → Zsh\n\nCheck which shell you’re currently using:\necho $SHELL\nIf the output does not end in /bash, you can start Bash manually by typing:\nbash\nThen check again with echo $SHELL. If you have trouble switching, don’t worry — nearly all commands in this tutorial will also work in Zsh.\n\n\n1.2.3 Windows\nUnlike macOS or Linux, Windows doesn’t include a Unix-style terminal by default, so you’ll need to install one of the following:\n\nMobaXterm (recommended)\n\nProvides a terminal with Linux-like commands, built-in\nInstallation guide: MobaXterm setup instructions\nEasiest option for beginners and lightweight to install.\n\nWindows Subsystem for Linux (WSL2)\n\nGives you a full Linux environment directly on Windows.\nRecommended if you’re comfortable installing software or already have some command-line experience.\nUses Ubuntu by default, which includes Bash and all standard Linux tools.\nInstallation guide:Microsoft WSL install instructions\n\n\nOnce installed, open your terminal (MobaXterm or Ubuntu via WSL2) and verify that Bash is available:\necho $SHELL",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Setting up a terminal</span>"
    ]
  },
  {
    "objectID": "source/terminal.html#sanity-check",
    "href": "source/terminal.html#sanity-check",
    "title": "1  Setting up a terminal",
    "section": "1.3 Sanity check",
    "text": "1.3 Sanity check\nAfter setup, open your terminal. You should see something like this:\n\nIf you see a prompt ending in $ (for example user@machine:~$), your shell is ready — you’re all set to follow along with the tutorial!",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Setting up a terminal</span>"
    ]
  },
  {
    "objectID": "source/documentation.html",
    "href": "source/documentation.html",
    "title": "2  Documenting your code",
    "section": "",
    "text": "2.1 Choosing your editor\nDocumenting your code is crucial for both your future self and anyone else who might work with your code. Good documentation helps others (and your future self) understand the purpose, functionality, and usage of your scripts, much like a detailed lab notebook.\nFor more in-depth guidance, see A Guide to Reproducible Code in Ecology and Evolution. While examples are mainly in R, the principles are general and apply across programming languages.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Documenting your code</span>"
    ]
  },
  {
    "objectID": "source/documentation.html#choosing-your-editor",
    "href": "source/documentation.html#choosing-your-editor",
    "title": "2  Documenting your code",
    "section": "",
    "text": "2.1.1 Plain text editor\nAvoid visual editors like Word, as they are not designed for code and can inadvertently change syntax (e.g., replacing backticks \\`` with apostrophes’`).\nStart simple with a plain text editor, such as:\n\nTextEdit (Mac)\nNotepad (Windows)\n\nThese allow you to write and save code safely, though they lack advanced features like syntax highlighting or integrated code execution.\n\n\n2.1.2 Rmarkdown in RStudio\nRMarkdown combines plain text, code, and documentation in one document. You can write your analysis and explanatory text together, then “knit” the document to HTML, PDF, or Word.\nTo create an RMarkdown file in RStudio:\n\nGo to File → New File → R Markdown\nChoose a title, author, and output format\nWrite your code and text\nClick Knit to render the document\n\nMore info: RMarkdown tutorial\n\n\n2.1.3 Quarto in Rstudio\nQuarto is a next-generation alternative to RMarkdown. It supports R, Python, and other languages, and offers more output formats and customization options.\nTo create a Quarto document:\n\nGo to File → New File → Quarto Document\nChoose a title, author, and output format\nClick Render to generate your document\n\nMore info: Quarto documentation",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Documenting your code</span>"
    ]
  },
  {
    "objectID": "source/documentation.html#markdown-for-documentation",
    "href": "source/documentation.html#markdown-for-documentation",
    "title": "2  Documenting your code",
    "section": "2.2 Markdown for Documentation",
    "text": "2.2 Markdown for Documentation\nMarkdown is a lightweight language for formatting text. You can easily add headers, lists, links, code, images, and tables.\nHeaders:\nUse # to add a header and separate different sections of your documentation. The more # symbols you use after each other, the smaller the header will be. When writing a header make sure to always put a space between the # and the header name.\n# Main Header\n## Subheader\nLists:\nUse - or * for unordered lists and numbers for ordered lists.\nOrdered lists are created by using numbers followed by periods. The numbers do not have to be in numerical order, but the list should start with the number one.\n1. First item\n2. Second item\n3. Third item\n4. Fourth item \n1. First item\n2. Second item\n3. Third item\n    1. Indented item\n    2. Indented item\n4. Fourth item \nUnordered lists are created using dashes (-), asterisks (*), or plus signs (+) in front of line items. Indent one or more items to create a nested list.\n- First item\n- Second item\n- Third item\n- Fourth item \n - First item\n- Second item\n- Third item\n    - Indented item\n    - Indented item\n- Fourth item \nYou can also combine ordered with unordered lists:\n1. First item\n2. Second item\n3. Third item\n    - Indented item\n    - Indented item\n4. Fourth item\nCode Blocks:\nEnclose code snippets in triple backticks followed by the computational language, i.e. bash or python, used.\n```bash\ngrep \"control\" downloads/Experiment1.txt\n```\nLinks:\nYou can easily add links to external resources or within your documentation as follows:\n[Link Text](https://www.example.com)\nEmphasis:\nYou can use * or _ to write italic and ** or __ for bold text.\n*italic*\n**bold**\nPictures\nYou can also add images to your documentation as follows:\n![Alt Text](path/to/your/image.jpg)\nHere, replace Alt Text with a descriptive alternative text for your image, and path/to/your/image.jpg with the actual path or URL of your image.\nTables\nTables can be useful for organizing information. Here’s a simple table:\n| Header 1 | Header 2 |\n| ---------| ---------|\n| Content 1| Content 2|\n| Content 3| Content 4|",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Documenting your code</span>"
    ]
  },
  {
    "objectID": "source/cli.html",
    "href": "source/cli.html",
    "title": "3  Navigating the command line",
    "section": "",
    "text": "3.1 pwd: Find out where we are\nOnce your terminal is open, let’s get oriented by typing your first command:\npwd\nThe command pwd stands for print working directory. It tells you where you currently are in the file system — that is, which folder (directory) your shell is “looking at” right now. You should see something like:",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Navigating the command line</span>"
    ]
  },
  {
    "objectID": "source/cli.html#pwd-find-out-where-we-are",
    "href": "source/cli.html#pwd-find-out-where-we-are",
    "title": "3  Navigating the command line",
    "section": "",
    "text": "/Users/YourUserName\n\n\n\n\n\n\nTipTip: Finding the Desktop on Different Systems\n\n\n\n\n\nYour home directory path varies slightly across operating systems. Here’s how to locate yourself and connect to familiar locations like the Desktop:\nmacOS\n\nYour home directory is /Users/YourUserName\nTo open the folder you are currently in Finder:open .\nYour desktop is at /Users/YourUserName/Desktop\n\nMobaXterm (Windows)\n\nYour home directory is /home/mobaxterm\nBy default, this is temporary and is deleted when you close MobaXterm. To make it permanent:\n\nGo to Settings –&gt; Configuration –&gt; General\nUnder Persistent home directory, choose a folder of your choice\n\nTo open the folder you are currently in the Windows File explorer: explorer.exe .\nYour Desktop is usually at: /mnt/c/Users/YourUserName/Desktop or /mnt/c/Users/YourUserName/OneDrive/Desktop (when using OneDrive)\n\nWSL2 (Windows)\n\nYour home directory is/home/YourUserName\nTo open the folder you are currently in the Windows File explorer: explorer.exe .\nYour Desktop is usually at: /mnt/c/Users/YourUserName/Desktop or /mnt/c/Users/YourUserName/OneDrive/Desktop (when using OneDrive)\n\nIf you want to access the Uva OneDrive folder:\nIf your OneDrive folder name includes spaces (like OneDrive - UvA), use quotes around the path:\n\ncd \"/mnt/c/Users/YourUserName/OneDrive - UvA\"",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Navigating the command line</span>"
    ]
  },
  {
    "objectID": "source/cli.html#ls-list-the-contents-of-a-directory",
    "href": "source/cli.html#ls-list-the-contents-of-a-directory",
    "title": "3  Navigating the command line",
    "section": "3.2 ls: List the contents of a directory",
    "text": "3.2 ls: List the contents of a directory\nNow that we know where we are, let’s find out what is inside that location. The command ls (short for list) shows the files and folders in your current directory. Type the following and press enter:\n\nls\n\nYou should see something like this (your output will vary depending on what’s in your directory):\n\nThe colors and formatting depend on your terminal settings, but typically:\n\nFolders (directories) appear in one color (often green or blue)\nFiles appear in another (often white or bold)\n\nIf your directory contains many items, the output can quickly become overwhelming. To make sense of it, we can use options and arguments to control how commands behave.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Navigating the command line</span>"
    ]
  },
  {
    "objectID": "source/cli.html#the-structure-of-a-command",
    "href": "source/cli.html#the-structure-of-a-command",
    "title": "3  Navigating the command line",
    "section": "3.3 The structure of a command",
    "text": "3.3 The structure of a command\nA command generally has three parts:\n\nA command: The program you want to run, i.e. ls\nAn option (or flag): A way to modify how the command behaves, i.e -l (long format)\nAn optional argument: The input, i.e. a file or folder\n\n\nTry the following command in your current directory to “List (ls) the contents of the current folder and show details in long format (-l)”:\n\nls -l\n\nAfter running this you should see a more detail list of the contents of your folder.In the example below we can see that we now print additional information about who owns the files (i.e. access modes), how large the files are, when they were last modified and of course the name:",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Navigating the command line</span>"
    ]
  },
  {
    "objectID": "source/cli.html#getting-help",
    "href": "source/cli.html#getting-help",
    "title": "3  Navigating the command line",
    "section": "3.4 Getting help",
    "text": "3.4 Getting help\nAt some point, you’ll want to know what options a command has or how it works. In this case, you can always check the manual pages (or man pages). Try this:\n\nman ls\n\nThis opens the manual entry for the command ls. You can scroll through it using:\n\n↑ / ↓ arrows or the space bar to move down,\nb to move back up,\nq to quit the manual.\n\nNot all commands use man. Depending on the program, there are a few common patterns you can try\n\nman ls\nls --help\nls -h\n\nFor complex software, like bioinformatics tools, the most helpful documentation is often:\n\nThe tool’s official website or GitHub repository\nThe –help output that lists all parameters and examples",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Navigating the command line</span>"
    ]
  },
  {
    "objectID": "source/cli.html#mkdir-make-a-new-folder",
    "href": "source/cli.html#mkdir-make-a-new-folder",
    "title": "3  Navigating the command line",
    "section": "3.5 mkdir: Make a new folder",
    "text": "3.5 mkdir: Make a new folder\nBefore we start moving around, let’s first learn how to create new folders (also called directories).This is something we will do often, for example, to keep raw data, results, and scripts organized in separate places. The command we use for that is mkdir, which stands for *make directory`.\nFor now, we will use it to create a shared working folder for this tutorial. Don’t worry about how to move into the folder yet — we’ll cover that next with the cd command.\n\n# Move into the home directory (the starting point of your system)\ncd ~\n\n# Create a new folder called 'data_analysis'\nmkdir data_analysis\n\n# Check that the folder was created successfully\nls\n\nYou should see a new folder called data_analysis appear in the list. We will use this folder as our project space for all exercises in this tutorial.\n\n# Move into the new folder\ncd data_analysis\n\n# Confirm where we are\npwd\n\nYou should now see that your current working directory (pwd) ends with /data_analysis. This is where we’ll keep all our files and run our commands for the next exercises.\n\n\n\n\n\n\nTipTip: Commenting your code\n\n\n\n\n\nNotice how we added # and some notes above each command?\nAnything written after # in Bash is a comment — it won’t be executed, but it helps you (and others) understand what the command does.\nIn your own work, add short, meaningful comments above key steps. Avoid restating the obvious — instead, explain why you’re doing something or what it achieves.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Navigating the command line</span>"
    ]
  },
  {
    "objectID": "source/cli.html#cd-move-around-folders",
    "href": "source/cli.html#cd-move-around-folders",
    "title": "3  Navigating the command line",
    "section": "3.6 cd: Move around folders",
    "text": "3.6 cd: Move around folders\nNow that we have our own project folder, let’s learn how to move around the file system.\nThe file system is structured like a tree, starting from a single “root” directory /. All other folders branch out from it.\n\nThere are two ways to specify a path:\n\nAbsolute path: starts from the root (e.g. /Users/Name/Documents)\nRelative path: starts from your current location (e.g. Documents if you’re already in /Users/Name)\n\nLet’s practice moving between folders (at each step, use pwd in case you feel that you get lost):\n\n# Make a new folder in data_analysis \nmkdir raw_reads \n\n# Move into a new folder (by using the relative path)\ncd raw_reads\n\n# Move one level up\ncd ..\n\n# Move multiple levels at once\ncd data_analysis/raw_reads\n\n# Quickly go back home\ncd ~\n\nIn the code above, the tilde symbol (~) is a shortcut for your home directory. It’s equivalent to typing the full absolute path to your home (e.g. /Users/YourName) but it is much faster to type.\n\n\n\n\n\n\nTipTip: Command-line completion\n\n\n\n\n\nSome tips for faster navigation:\n\nUse Tab for autocompletion — type the first few letters of a folder name and press Tab.\nIf there’s more than one match, press Tab twice to see all options.\nUse ↑ / ↓ arrows to scroll through previously entered commands\n\n\n\n\n\n\n\n\n\n\nCautionExercise\n\n\n\n\n\n\nCreate a new folder inside your data_analysis directory called results.\nMove into that folder and confirm your location with pwd.\nMove back to data_analysis using cd …\nUse ls to confirm both results and raw_reads are there.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Navigating the command line</span>"
    ]
  },
  {
    "objectID": "source/cli.html#wget-download-data",
    "href": "source/cli.html#wget-download-data",
    "title": "3  Navigating the command line",
    "section": "3.7 wget: Download data",
    "text": "3.7 wget: Download data\nNext, let’s download a sequencing file for this exercise. We’ll use wget to fetch a file barcode01_merged.fastq.gz from the web:\n\n# Download the example fastq into the current directory\nwget https://github.com/ndombrowski/MicEco2025/raw/refs/heads/main/data/barcode01_merged.fastq.gz\n\nAfter you download data, it is always a good idea to do some sanity check to see if the file is present and check how large it is:\n\n# list files in long and human-readable format\nls -lh barcode01_merged.fastq.gz\n\n# alternative: disk usage of that file\ndu -h barcode01_merged.fastq.gz",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Navigating the command line</span>"
    ]
  },
  {
    "objectID": "source/cli.html#cp-copy-files",
    "href": "source/cli.html#cp-copy-files",
    "title": "3  Navigating the command line",
    "section": "3.8 cp: Copy files",
    "text": "3.8 cp: Copy files\ncp duplicates files or directories. Let’s use it to copy the downloaded file into raw_reads:\n\n# Copy file into raw_reads \ncp barcode01_merged.fastq.gz raw_reads/\n\n# Show content of both locations\nls -l\nls -l raw_reads\n\nWhen running the two ls commands, we see that we now have two copies of seq_project.tar.gz, one file is in our working directory and the other one is in our data folder. Copying large amounts of data is not ideal since we will use unneccassary space. However, we can use another command to move the tar folder into our data folder.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Navigating the command line</span>"
    ]
  },
  {
    "objectID": "source/cli.html#mv-move-or-rename-files",
    "href": "source/cli.html#mv-move-or-rename-files",
    "title": "3  Navigating the command line",
    "section": "3.9 mv: Move (or rename) files",
    "text": "3.9 mv: Move (or rename) files\nmv moves or renames files without creating a second copy:\n\n# Move the file into raw_reads\nmv barcode01_merged.fastq.gz raw_reads/\n\n# Verify\nls -l\nls -l raw_reads\n\nNotice that mv will move the tar file and, without asking, overwrite the existing tar file we had in the data folder when we ran cp. This means for you that if you run move its best to make sure that you do not overwrite files by mistake.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Navigating the command line</span>"
    ]
  },
  {
    "objectID": "source/cli.html#rm-remove-files-and-directories",
    "href": "source/cli.html#rm-remove-files-and-directories",
    "title": "3  Navigating the command line",
    "section": "3.10 rm: Remove files and directories",
    "text": "3.10 rm: Remove files and directories\nTo remove files and folders, we use the rm command. We want to remove the barcode01_merged.fastq.gz file since we do not need two copies:\n\n# Remove a file\nrm barcode01_merged.fastq.gz\n\n# Check if that worked\nls -l\n\nIf we want to remove a folder, we need to tell rm that we want to remove folders using an option. To do this, we use -r , which allows us to remove directories and their contents recursively.\n\n\n\n\n\n\nImportant\n\n\n\nUnix does not have an undelete command.\nThis means that if you delete something with rm, it’s gone. Therefore, use rm with care and check what you write twice before pressing enter! Also, NEVER run rm -rf on the root / folder or any important path. Always double check the path or file name before pressing enter.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Navigating the command line</span>"
    ]
  },
  {
    "objectID": "source/cli.html#exploring-file-contents",
    "href": "source/cli.html#exploring-file-contents",
    "title": "3  Navigating the command line",
    "section": "3.11 Exploring file contents",
    "text": "3.11 Exploring file contents\nBefore working with large compressed sequencing files, let’s get comfortable with some basic tools to inspect text files. These commands are useful for quickly checking what a file contains without opening it in a text editor.\n\n# Download Alice Adventures in Wonderland\nwget https://www.gutenberg.org/files/11/11-0.txt\n\n# Verify \nls -lh 11-0.txt\n\n\n3.11.1 cat: Print the full file\nWe can use cat print the entire file to the screen — fine for short files, but overwhelming for long ones.\n\ncat 11-0.txt\n\n\n\n3.11.2 head and tail: View parts of a file\nTo only print the first few or last few lines we can use the head and tail command, respectively:\n\n# Show the first 10 lines (default)\nhead 11-0.txt\n\n# Show the last 5 lines\ntail -n 5 11-0.txt\n\n\n\n3.11.3 less: View the full file\nless let’s you view a file’s contents one screen at a time. This is useful when dealing with a large text file (such as a sequence data file) because it doesn’t load the entire file but accesses it page by page, resulting in fast loading speeds.\n\nless -S 11-0.txt\n\n\nYou can use the arrow Up and Page arrow keys to move through the text file\nTo exit less, type q\n\n\n\n\n\n\n\nTipTip: Editing text files\n\n\n\n\n\nYou can also edit the content of a text file and there are different programs available to do this on the command line, the most commonly used tool is nano, which should come with most command line interpreters. You can open any file as follows:\n\nnano 11-0.txt\n\nOnce the document is open you can edit it however you want and then\n\nClose the document with control + X\nType y to save changes and press enter",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Navigating the command line</span>"
    ]
  },
  {
    "objectID": "source/cli.html#wc-count-things",
    "href": "source/cli.html#wc-count-things",
    "title": "3  Navigating the command line",
    "section": "3.12 wc: Count things",
    "text": "3.12 wc: Count things\nAnother useful tool is the wc (= wordcount) command that allows us to count the number of lines via -l in a file. It is an useful tool for sanity checking and here allows us to count how many lines of text are found in the text document.\n\nwc -l 11-0.txt",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Navigating the command line</span>"
    ]
  },
  {
    "objectID": "source/cli.html#pipes",
    "href": "source/cli.html#pipes",
    "title": "3  Navigating the command line",
    "section": "3.13 Pipes",
    "text": "3.13 Pipes\nSo far, we’ve run one command at a time — for example, using wc -l to count lines or head to look at the first few lines. But often, you’ll want to combine commands so that the output of one becomes the input of another. That’s what the pipe (|) does.\n\n# Example: show only the first 5 lines of the line count output\ncat 11-0.txt | head -n 5\n\nHere:\n\ncat 11-0.txtprints the full text.\nThe pipe (|) sends that output directly to head.\nhead -n 5 only shows the first 5 lines of the result.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Navigating the command line</span>"
    ]
  },
  {
    "objectID": "source/cli.html#zcat-and-head-working-with-compressed-files",
    "href": "source/cli.html#zcat-and-head-working-with-compressed-files",
    "title": "3  Navigating the command line",
    "section": "3.14 zcat and head: Working with compressed files",
    "text": "3.14 zcat and head: Working with compressed files\nNow that you know how to combine commands, let’s try the same idea with a compressed file.\nThe .gzending we have in the sequence data file means that the file is compressed with gzip. To view its contents without uncompressing it, we use zcat. Because these files can be very large, we’ll use a pipe again to only view the first few line\n\nzcat raw_reads/barcode01_merged.fastq.gz | head\n\nThis command:\n\nDecompresses the file temporarily (zcat),\nSends the decompressed text through a pipe (|),\nDisplays only the first few lines (head).\n\nFor macOS users, the equivalent command is often gzcat:\n\ngzcat raw_reads/barcode01_merged.fastq.gz | head",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Navigating the command line</span>"
    ]
  },
  {
    "objectID": "source/cli.html#working-with-multiple-files",
    "href": "source/cli.html#working-with-multiple-files",
    "title": "3  Navigating the command line",
    "section": "3.15 Working with multiple files",
    "text": "3.15 Working with multiple files\nSo far, we’ve worked with single files. In practice, sequencing data often comes as multiple files — for example, one FASTQ file per barcode. Let’s practice handling several files at once.\n\n3.15.1 touch: Make example files\nTo try this safely, we’ll create a few empty “dummy” files in our raw_reads folder using the touch command:\n\ncd raw_reads \n\n# Create a few dummy FASTQ files\ntouch barcode02_01.fastq barcode02_02.fastq barcode03_01.fastq\n\n# Check what was done\nls -lh\n\n\n\n3.15.2 Wildcards (*): Match multiple files\nTyping every filename can get tedious. Wildcards help you work with groups of files using pattern matching.\n\n# List all files that start with \"barcode02\"\nls barcode02_*\n\n# List all files ending with \".fastq\"\nls *.fastq\n\n\n\n3.15.3 cat: Combining files\nThe cat command doesn’t just print files — it can also concatenate (join) multiple files into one. For example, if you have several sequencing runs from the same barcode and want to merge them:\n\n# Combine the two barcode01 files into one merged file\ncat barcode02_*.fastq &gt; barcode02_all.fastq\n\nHere:\n\nbarcode01_*.fastqselects all files that start with barcode01_\n&gt; tells the shell to write the combined output into a new file called barcode01_merged.fastq\n\n\n\n\n\n\n\nCautionImportant: Be careful with &gt;\n\n\n\n\n\nThe &gt; operator overwrites files without asking. If you want to add (append) to an existing file instead of replacing it, use &gt;&gt;:",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Navigating the command line</span>"
    ]
  }
]